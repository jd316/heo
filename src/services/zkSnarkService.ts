// src/services/zkSnarkService.ts
import { logger } from '../utils/logger.ts';
import { ApplicationError, ErrorCode } from '../utils/errorHandling.ts';
import { solanaService } from './solanaService.ts';
import type { ProofData } from './solanaService.ts';
import { ipfsService } from './ipfsService.ts';
import * as snarkjs from 'snarkjs'; // Import snarkjs
import * as fs from 'fs'; // Import fs for reading verification key
import * as path from 'path';
import type { ElizaOSContext } from '../elizaos/types.ts';

// Configuration constants
const _IS_PRODUCTION = process.env.NODE_ENV === 'production';
const PROOF_GENERATION_TIME_MS = 3200; // 3.2s as per PRD requirements

// Define paths for the protocol_check circuit
// These files were generated by the Circom and snarkjs setup process.
// const PROTOCOL_CHECK_CIRCUIT_DIR = './circuits'; // Removed unused constant
const PROTOCOL_CHECK_CIRCUIT_WASM_PATH =
  process.env.PROTOCOL_CHECK_CIRCUIT_WASM_PATH ||
  'circuits/protocol_check_js/protocol_check.wasm'; // Default path
const PROTOCOL_CHECK_CIRCUIT_ZKEY_PATH =
  process.env.PROTOCOL_CHECK_CIRCUIT_ZKEY_PATH || 'circuits/protocol_check_final.zkey'; // Default path
const PROTOCOL_CHECK_VERIFICATION_KEY_PATH =
  process.env.PROTOCOL_CHECK_VERIFICATION_KEY_PATH || 'circuits/verification_key.json'; // Default path

// Type for the proof generated by snarkjs
export type Groth16Proof = snarkjs.Groth16Proof; // Re-exporting for clarity in other services
export type PublicSignals = snarkjs.PublicSignals;

/**
 * Interface for experimental data that will be processed into circuit inputs.
 */
export interface ExperimentalReagent {
  id: string;
  name: string;
  is_hazardous: boolean;
  quantity_used: number;
  unit: string;
}

export interface ExperimentalStep {
  step_id: string;
  description: string;
  equipment_used?: string[];
  settings?: Record<string, unknown>;
  actions_taken?: string[];
}

export interface ExperimentalData {
  experiment_id: string;
  protocol_template_id: string;
  reagents_used: ExperimentalReagent[];
  procedure_steps: ExperimentalStep[];
  safety_measures_observed: {
    safety_cabinet_used: boolean;
    ppe_kit_used: boolean;
    // ... other safety flags
  };
  // ... other raw observations, instrument readings, etc.
  raw_instrument_outputs?: Record<string, unknown>;
}

/**
 * Interface for parameters required to generate a zkSNARK proof
 */
export interface ProofParameters {
  protocolInstanceId: string;
  rawData: ExperimentalData; // Use the new detailed interface
  // inputs?: Record<string, unknown>; // This can be removed if prepareCircuitInputs is always used
}

/**
 * Interface for zkSNARK proof result
 */
export interface ProofResult {
  proof: ProofData; // This should align with snarkjs proof structure if possible
  publicInputs: unknown; // Public inputs used for verification
  ipfsCid: string; // Reference to stored data in IPFS
  timestamp: string;
}

/**
 * Defines the specific inputs for the protocol_check.circom circuit.
 */
export interface ProtocolCheckCircuitInputs {
  hazardous_reagent_present: 0 | 1; // 1 if hazardous, 0 otherwise
  safety_cabinet_used: 0 | 1; // 1 if used, 0 otherwise
}

/**
 * Represents the structure of a zkSNARK proof along with its public signals.
 */
export interface ZkSnarkProof {
  proof: Groth16Proof;
  publicSignals: PublicSignals; // Array of strings representing public inputs/outputs
}

/**
 * Service for generating and verifying zkSNARK proofs
 * Implements Groth16 proving system as specified in the PRD
 */
class ZkSnarkService {
  private circuitWasmPath: string;
  private circuitZkeyPath: string;
  private verificationKeyPath: string;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private verificationKeyJson: any; // To cache the loaded verification key, type from snarkjs is unclear

  constructor() {
    this.circuitWasmPath = path.resolve(PROTOCOL_CHECK_CIRCUIT_WASM_PATH);
    this.circuitZkeyPath = path.resolve(PROTOCOL_CHECK_CIRCUIT_ZKEY_PATH);
    this.verificationKeyPath = path.resolve(PROTOCOL_CHECK_VERIFICATION_KEY_PATH);

    logger.info('ZkSnarkService: Initializing with circuit paths', {
      wasm: this.circuitWasmPath,
      zkey: this.circuitZkeyPath,
      vkey: this.verificationKeyPath,
    });

    this.loadVerificationKey();
  }

  initialize(context: ElizaOSContext): void {
    // No setup required for ZkSnarkService
    context.logger?.info('ZkSnarkService: initialized');
  }

  private async loadVerificationKey(): Promise<void> {
    if (!fs.existsSync(this.verificationKeyPath)) {
      logger.error(
        `ZkSnarkService: Verification key file not found at ${this.verificationKeyPath}. Proof verification will fail.`,
      );
      this.verificationKeyJson = null; // Ensure it's null if not found
      return;
    }
    try {
      const vKeyJsonString = fs.readFileSync(this.verificationKeyPath, 'utf-8');
      this.verificationKeyJson = JSON.parse(vKeyJsonString);
      logger.info(
        `ZkSnarkService: Verification key loaded successfully from ${this.verificationKeyPath}`,
      );
    } catch (error) {
      logger.error(
        `ZkSnarkService: Error loading or parsing verification key from ${this.verificationKeyPath}`,
        { error },
      );
      this.verificationKeyJson = null; // Ensure it's null on error
    }
  }

  /**
   * Helper to prepare circuit inputs from rawData for the protocol_check.circom circuit.
   */
  private prepareCircuitInputs(rawData: ExperimentalData): Record<string, number> {
    logger.info('ZkSnarkService: Preparing inputs for protocol_check circuit', { experimentId: rawData.experiment_id });

    // Determine if any hazardous reagents are present
    let hazardousReagentPresent = 0;
    if (Array.isArray(rawData.reagents_used)) {
    for (const reagent of rawData.reagents_used) {
        if (reagent?.is_hazardous) {
        hazardousReagentPresent = 1;
        break;
        }
      }
    }

    const safetyCabinetUsed = rawData.safety_measures_observed?.safety_cabinet_used ? 1 : 0;

    const circuitInputs = {
      hazardous_reagent_present: hazardousReagentPresent,
      safety_cabinet_used: safetyCabinetUsed,
    };

    logger.info('ZkSnarkService: Prepared circuit inputs', { circuitInputs });
    return circuitInputs;
  }

  /**
   * Generate a zkSNARK proof
   */
  async generateProof(params: ProofParameters): Promise<ProofResult> {
    logger.info('ZkSnarkService: Starting proof generation', {
      protocolInstanceId: params.protocolInstanceId,
    });

    try {
      // Store the full rawData on IPFS
      const ipfsCid = await ipfsService.store(
        JSON.stringify(params.rawData)
      );
      logger.info('ZkSnarkService: Raw experimental data stored on IPFS', { ipfsCid });

      // Prepare inputs for the circuit from rawData
      const circuitInputs = this.prepareCircuitInputs(params.rawData);
      
      logger.info('ZkSnarkService: Running Groth16 prover with snarkjs...');
      
      // For production, consider how to handle missing files. Throw error if critical.
      if (!fs.existsSync(this.circuitWasmPath) || !fs.existsSync(this.circuitZkeyPath)) {
        logger.error(`ZkSnarkService: Critical circuit files not found. WASM: ${this.circuitWasmPath}, ZKEY: ${this.circuitZkeyPath}. Cannot generate proof.`);
        if (_IS_PRODUCTION) {
            throw new ApplicationError(
                'Circuit files are missing, cannot generate proof.',
                ErrorCode.SERVICE_UNAVAILABLE
            );
        }
        // Fallback to mock proof generation if files are missing (DEV ONLY)
        logger.warn('ZkSnarkService: Falling back to mock proof due to missing circuit files (DEV ONLY).');
      await new Promise(resolve => setTimeout(resolve, PROOF_GENERATION_TIME_MS));
        const mockProofData: ProofData = {
          pi_a: ["0x0", "0x0"],
          pi_b: [["0x0", "0x0"], ["0x0", "0x0"]],
          pi_c: ["0x0", "0x0"],
        protocol: "groth16",
        curve: "bn128"
      };
        // Public inputs should reflect what the circuit would output if it ran with these inputs.
        // For protocol_check.circom, there are no explicit public outputs other than the implicit success/failure.
        // snarkjs.groth16.fullProve returns `publicSignals` which would be empty for this circuit.
        // So, we can use the inputs themselves or a hash of them if needed for on-chain reference.
        const mockPublicInputs = circuitInputs; // Or a hash
        return {
            proof: mockProofData,
            publicInputs: mockPublicInputs,
            ipfsCid,
            timestamp: new Date().toISOString(),
        };
      }

      const { proof, publicSignals } = await snarkjs.groth16.fullProve(
        circuitInputs, 
        this.circuitWasmPath, 
        this.circuitZkeyPath,
        { info: (msg: string) => logger.info(msg), debug: (msg: string) => logger.debug(msg) } 
      );
      logger.info('ZkSnarkService: snarkjs proof generation complete.');
      
      const proofResult: ProofResult = {
        proof: proof as ProofData, 
        publicInputs: publicSignals, // For protocol_check.circom, publicSignals will be an empty array.
        ipfsCid,
        timestamp: new Date().toISOString(),
      };
      
      return proofResult;
    } catch (error) {
      logger.error('Failed to generate zkSNARK proof:', error);
      throw new ApplicationError(
        'Failed to generate zkSNARK proof', 
        ErrorCode.INTERNAL_ERROR,
        { protocolInstanceId: params.protocolInstanceId, error: error instanceof Error ? error.message : String(error) }
      );
    }
  }

  /**
   * Verify a zkSNARK proof
   */
  async verifyProof(proof: ProofData, publicSignals: string[]): Promise<boolean> {
    logger.info('ZkSnarkService: Verifying proof');
    try {
      if (!fs.existsSync(this.verificationKeyPath)) {
        logger.error(`ZkSnarkService: Verification key not found: ${this.verificationKeyPath}. Cannot verify proof.`);
        if (_IS_PRODUCTION) {
            throw new ApplicationError(
                'Verification key is missing, cannot verify proof.',
                ErrorCode.SERVICE_UNAVAILABLE
            );
        }
        logger.warn('ZkSnarkService: Mocking verification due to missing verification key (DEV ONLY).');
        await new Promise(resolve => setTimeout(resolve, 500)); 
        return Math.random() < 0.95; // Mock verification success rate for dev
      }
      const isValid = await snarkjs.groth16.verify(
        this.verificationKeyJson,
        publicSignals,
        proof as Groth16Proof
      ); 
      
      logger.info(`ZkSnarkService: Proof verification ${isValid ? 'successful' : 'failed'}`);
      return isValid;
    } catch (error) {
      logger.error('Failed to verify zkSNARK proof:', error);
      throw new ApplicationError(
        'Failed to verify zkSNARK proof', 
        ErrorCode.INTERNAL_ERROR,
        { error: error instanceof Error ? error.message : String(error) }
      );
    }
  }

  /**
   * Generate proof and anchor it on Solana in one operation
   */
  async generateAndAnchorProof(params: ProofParameters): Promise<{
    proofResult: ProofResult;
    transactionId: string;
  }> {
    const proofResult = await this.generateProof(params);
    const transactionId = await solanaService.anchorProof(
      params.protocolInstanceId,
      proofResult.proof,
      proofResult.ipfsCid,
      // Note: solanaService.anchorProof might need to be adapted if publicInputs
      // also need to be stored on-chain or referenced.
    );
    logger.info('ZkSnarkService: Proof anchored on Solana', { transactionId });
    return { proofResult, transactionId };
  }

  /**
   * Generates a Groth16 proof for the protocol_check circuit.
   * PRD: "Groth16 proving system (3.2s/proof)"
   * @param circuitInputs The specific inputs for the protocol_check circuit.
   * @returns A Promise resolving to the ZkSnarkProof object.
   */
  async runGroth16Prover(
    circuitInputs: ProtocolCheckCircuitInputs, // Changed from Record<string, any>
    _context?: ElizaOSContext,
  ): Promise<ZkSnarkProof> {
    logger.info('ZkSnarkService: Attempting to generate Groth16 proof for ProtocolCheck circuit.', {
      inputs: circuitInputs,
    });

    // Validate that circuit files exist before attempting to prove
    if (!fs.existsSync(this.circuitWasmPath)) {
      logger.error(
        `ZkSnarkService: Circuit WASM file not found at ${this.circuitWasmPath}. Cannot generate proof.`,
      );
      throw new Error(
        `Circuit WASM file missing. Expected at ${this.circuitWasmPath}`,
      );
    }
    if (!fs.existsSync(this.circuitZkeyPath)) {
      logger.error(
        `ZkSnarkService: Circuit ZKEY file not found at ${this.circuitZkeyPath}. Cannot generate proof.`,
      );
      throw new Error(
        `Circuit ZKEY file missing. Expected at ${this.circuitZkeyPath}`,
      );
    }

    try {
      const startTime = Date.now();
      // Inputs for snarkjs.groth16.fullProve must match the circuit's signal names
      const inputsForSnarkJs = {
        hazardous_reagent_present: BigInt(circuitInputs.hazardous_reagent_present),
        safety_cabinet_used: BigInt(circuitInputs.safety_cabinet_used),
    };

      const { proof, publicSignals } = await snarkjs.groth16.fullProve(
        inputsForSnarkJs,
        this.circuitWasmPath,
        this.circuitZkeyPath,
        // logger // snarkjs.groth16.fullProve can take a logger object, but it needs to match its expected interface.
                 // For now, we'll use our own logger outside.
      );
      const endTime = Date.now();
      logger.info(
        `ZkSnarkService: Groth16 proof generated successfully in ${endTime - startTime}ms.`,
        { publicSignals }
      );

      // Ensure proof structure is as expected by snarkjs.Groth16Proof type
      // The snarkjs.Groth16Proof type is an interface like:
      // { pi_a: [string, string, string?], pi_b: [[string, string], [string, string], [string, string]?], pi_c: [string, string, string?], protocol: string, curve: string }
      // The publicSignals is string[]
      return { proof: proof as Groth16Proof, publicSignals };
    } catch (error) {
      logger.error('ZkSnarkService: Error generating Groth16 proof', {
        error: error instanceof Error ? error.message : String(error),
        inputs: circuitInputs,
      });
      // Consider if a more specific error type or message is needed for callers.
      throw new Error(
        `Failed to generate Groth16 proof: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Verifies a Groth16 proof.
   * @param proof The Groth16Proof object.
   * @param publicSignals The public signals associated with the proof.
   * @returns A Promise resolving to true if the proof is valid, false otherwise.
   */
  async verifyGroth16Proof(
    proof: Groth16Proof,
    publicSignals: PublicSignals,
    _context?: ElizaOSContext,
  ): Promise<boolean> {
    logger.info('ZkSnarkService: Verifying Groth16 proof.', { publicSignals });

    if (!this.verificationKeyJson) {
        logger.error(
          `ZkSnarkService: Verification key not loaded. Cannot verify proof. Check path: ${this.verificationKeyPath}`
        );
        // Attempt to reload it once in case it was a transient issue during construction
        await this.loadVerificationKey();
        if (!this.verificationKeyJson) {
            return false; // Still not loaded, verification fails
        }
    }
    
    try {
      const isValid = await snarkjs.groth16.verify(
        this.verificationKeyJson,
        publicSignals,
        proof,
        // logger // snarkjs.groth16.verify can also take a logger
      );
      logger.info(`ZkSnarkService: Proof verification result: ${isValid}`);
      return isValid;
    } catch (error) {
      logger.error('ZkSnarkService: Error during proof verification', {
        error: error instanceof Error ? error.message : String(error),
      });
      return false; // Assume invalid on error
    }
  }

  // --- Mock/Fallback functions (kept for reference or extreme fallback, but primary paths are real) ---
  // These are less relevant now that we're aiming for real proving.

  /**
   * MOCK: Simulates generating a zkSNARK proof for generic data.
   * This is a placeholder and does NOT perform real cryptographic operations.
   */
  async runMockGroth16Prover(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _circuitInputs: Record<string, any>, // Keeping 'any' for mock flexibility, disabled explicit-any for this line
    _context?: ElizaOSContext,
  ): Promise<ZkSnarkProof> {
    logger.warn(
      'ZkSnarkService: runMockGroth16Prover is being called. This is a MOCK implementation.',
    );
    // Simulate delay as per PRD (3.2s)
    await new Promise((resolve) => setTimeout(resolve, 3200));

    // Generate a plausible-looking mock proof structure
    const mockProof: Groth16Proof = {
      pi_a: ['1', '2', '3'], // Mocked values
      pi_b: [
        ['4', '5'],
        ['6', '7'],
        ['8', '9'],
      ],
      pi_c: ['10', '11', '12'],
      protocol: 'groth16',
      curve: 'bn128', // Common curve for snarkjs examples
    };
    // Mock public signals - these would correspond to the circuit's public inputs/outputs
    const mockPublicSignals: PublicSignals = ['1', '0']; // Example for the ProtocolCheck circuit (valid if hazardous=1, cabinet=1)

    logger.info('ZkSnarkService: Mock proof generated.');
    return { proof: mockProof, publicSignals: mockPublicSignals };
  }

  /**
   * MOCK: Simulates verifying a zkSNARK proof.
   * This is a placeholder and does NOT perform real cryptographic verification.
   */
  async verifyMockGroth16Proof(
    _proof: Groth16Proof,
    _publicSignals: PublicSignals,
    _context?: ElizaOSContext,
  ): Promise<boolean> {
    logger.warn(
      'ZkSnarkService: verifyMockGroth16Proof is being called. This is a MOCK implementation.',
    );
    // Simulate some basic check, e.g., if public signals are not empty
    // const isValid = _publicSignals && _publicSignals.length > 0;
    // For the mock, let's usually return true to simulate successful verification.
    return true;
  }
}

// Export the runGroth16Prover function as a standalone function for compatibility
// with import comments in validationService
export async function runGroth16Prover(
  protocolInstanceId: string,
  rawData: ExperimentalData,
  // inputs?: Record<string, unknown> // Changed from any to unknown
): Promise<ProofResult> {
  return zkSnarkService.generateProof({
    protocolInstanceId,
    rawData,
    // inputs, // This is now derived by prepareCircuitInputs from rawData
  });
}

// Export singleton instance
export const zkSnarkService = new ZkSnarkService(); 